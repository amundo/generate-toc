// generate-toc.js
// Run with: deno run --allow-read --allow-write generate-index.js

import { walk } from 'jsr:@std/fs/walk'

// ----- 1. Build a directory tree structure -----
// We'll build a tree like:
// {
//   name: "",
//   children: {
//     "subdir": { name: "subdir", children: { ... }, files: ["a.txt", "b.md"] },
//     ...
//   },
//   files: ["rootfile.txt", ...]
// }

function createNode(name = '') {
  return {
    name,
    children: new Map(), // dirName -> node
    files: [],           // [ "fileA.txt", ... ]
  }
}

function insertPath(root, pathParts) {
  // pathParts: ["dirA", "dirB", "file.txt"] or ["file.txt"]
  if (pathParts.length === 0) return

  if (pathParts.length === 1) {
    // It's a file
    root.files.push(pathParts[0])
    return
  }

  const [dir, ...rest] = pathParts
  if (!root.children.has(dir)) {
    root.children.set(dir, createNode(dir))
  }
  insertPath(root.children.get(dir), rest)
}

// ----- 2. Walk the filesystem and populate the tree -----

async function buildTree(rootDir = '.') {
  const root = createNode('')

  for await (const entry of walk(rootDir, {
    includeDirs: false,
    includeSymlinks: false,
    followSymlinks: false,
  })) {
    const relPath = entry.path.replace(/^[.][/]?/, '') // remove leading "./"
    if (!relPath) continue

    // skip hidden files/dirs and this output file
    if (
      relPath === 'table-of-contents.html' ||
      relPath.startsWith('.') ||
      relPath.split('/').some(part => part.startsWith('.'))
    ) {
      continue
    }

    const parts = relPath.split('/')
    insertPath(root, parts)
  }

  return root
}

// ----- 3. Render the tree to nested <ul> HTML -----

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
}

// Returns HTML for a node's contents (directories first, then files)
function renderNode(node, parentPath = '') {
  let html = '<ul>\n'

  // Directories (sorted)
  const dirNames = [...node.children.keys()].sort((a, b) => a.localeCompare(b))
  for (const dirName of dirNames) {
    const child = node.children.get(dirName)
    const dirRelPath = parentPath ? `${parentPath}/${dirName}` : dirName

    html += `  <li class="dir"><span class="dirname">${escapeHtml(dirName)}/</span>\n`
    html += renderNode(child, dirRelPath)
    html += '  </li>\n'
  }

  // Files (sorted)
  const fileNames = [...node.files].sort((a, b) => a.localeCompare(b))
  for (const fileName of fileNames) {
    const fileRelPath = parentPath ? `${parentPath}/${fileName}` : fileName
    html += `  <li class="file"><a href="${encodeURI(fileRelPath)}">${escapeHtml(fileName)}</a></li>\n`
  }

  html += '</ul>\n'
  return html
}

// ----- 4. Assemble full HTML page and write it -----

function wrapPage(bodyHtml) {
  return `<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Table of Contents</title>
<style>
  :root {
    color-scheme: light dark;
    --bg: #fff;
    --fg: #000;
    --dir: #2563eb;
    --file: inherit;
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #0f172a;
      --fg: #f8fafc;
      --dir: #60a5fa;
    }
  }

  body {
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                 Roboto, "Helvetica Neue", sans-serif;
    line-height: 1.5;
    padding: 2rem;
    max-width: 60rem;
  }

  h1 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }

  ul {
    list-style-type: none;
    padding-left: 1rem;
    margin: 0.25rem 0;
    border-left: 1px solid color-mix(in srgb, var(--fg) 20%, transparent);
  }
  li {
    margin: 0.25rem 0;
  }
  .dir > .dirname {
    color: var(--dir);
    font-weight: 600;
  }
  .file > a {
    color: var(--file);
    text-decoration: none;
  }
  .file > a:hover {
    text-decoration: underline;
  }

  footer {
    margin-top: 2rem;
    font-size: .8rem;
    opacity: .7;
  }
</style>

<body>
<h1>Table of Contents</h1>

${bodyHtml}

<footer>
  Generated by generate-index.js on ${new Date().toISOString()}
</footer>
</body>
</html>
`
}

async function main() {
  const tree = await buildTree('.')
  const tocHtml = renderNode(tree, '')
  const fullHtml = wrapPage(tocHtml)

  await Deno.writeTextFile('table-of-contents.html', fullHtml)
  console.log('Wrote table-of-contents.html')
}

if (import.meta.main) {
  main()
}
